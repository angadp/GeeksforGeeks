[
{"text": "Subtract Two Numbers represented as Linked Lists"},
{"text": "Check if a linked list is Circular Linked List"},
{"text": "Create a Doubly Linked List from a Ternary Tree"},
{"text": "Rearrange a given list such that it consists of alternating minimum maximum elements"},
{"text": "Convert a Binary Tree to a Circular Doubly Link List"},
{"text": "In-place Merge two linked lists without changing links of first list"},
{"text": "Unrolled Linked List | Set 1 (Introduction)"},
{"text": "Delete middle of linked list"},
{"text": "Decimal Equivalent of Binary Linked List"},
{"text": "Flatten a multi-level linked list | Set 2 (Depth wise)"},
{"text": "Merge K sorted linked lists"}
][
{"content": "\r\n\t\t\t", "text": "Create a Doubly Linked List from a Ternary Tree"},
{"content": "\r\n\t\t\t", "text": "In-place Merge two linked lists without changing links of first list"},
{"content": "\r\n\t\t\t", "text": "Merge K sorted linked lists"},
{"content": "\r\n\t\t\t", "text": "Rearrange a given list such that it consists of alternating minimum maximum elements"},
{"content": "\r\n\t\t\t", "text": "Flatten a multi-level linked list | Set 2 (Depth wise)"},
{"content": "\r\n\t\t\t", "text": "Delete middle of linked list"},
{"content": "\r\n\t\t\t", "text": "Check if a linked list is Circular Linked List"},
{"content": "\r\n\t\t\t", "text": "Decimal Equivalent of Binary Linked List"},
{"content": "\r\n\t\t\t", "text": "Unrolled Linked List | Set 1 (Introduction)"},
{"content": "\r\n\t\t\t", "text": "Subtract Two Numbers represented as Linked Lists"},
{"content": "\r\n\t\t\t", "text": "Convert a Binary Tree to a Circular Doubly Link List"}
][
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Check if a linked list is Circular Linked List"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Delete middle of linked list"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Create a Doubly Linked List from a Ternary Tree"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "In-place Merge two linked lists without changing links of first list"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\nOutput:\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Rearrange a given list such that it consists of alternating minimum maximum elements"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Flatten a multi-level linked list | Set 2 (Depth wise)"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\nA Simple Solution is to initialize result as first list.  Now traverse all lists starting from second list. Insert every node of currently traversed list into result in a sorted way.  Time complexity of this solution is O(N", ") where N is total number of nodes, i.e., N = kn.\n", "\nA ", "is to use Min Heap based solution which is discussed ", " for arrays.  Time complexity of this solution would be O(nk Log k)\n", "\nIn this post, ", " approach is discussed.  This approach doesn\u2019t require extra space for heap and works in O(nk Log k)\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Merge K sorted linked lists"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Decimal Equivalent of Binary Linked List"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Unrolled Linked List | Set 1 (Introduction)"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\nOutput:\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Convert a Binary Tree to a Circular Doubly Link List"},
{"content": ["\r\n\t\t\t", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n\r\n\t\t\t", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n\r\n", "\r\n\r\n\t\t"], "text": "Subtract Two Numbers represented as Linked Lists"}
][
{"content": ["Given two sorted singly linked lists having n and m elements each, merge them using constant space. First n smallest elements in both the lists should become part of first list and rest elements should be part of second list. Sorted order should be maintained. We are not allowed to change pointers of first linked list.", "For example,\n", "The problem becomes very simple if we\u2019re allowed to change pointers of first linked list. If we are allowed to change links, we can simply do something like merge of merge-sort algorithm. We assign first n smallest elements to the first linked list where n is the number of elements in first linked list and the rest to second linked list. We can achieve this in O(m + n) time and O(1) space, but this solution violates the requirement that we can\u2019t change links of first list.", "The problem becomes a little tricky as we\u2019re not allowed to change pointers in first linked list. The idea is something similar to ", " post but as we are given singly linked list, we can\u2019t proceed backwards with the last element of LL2. ", "The idea is for each element of LL1, we compare it with first element of LL2. If LL1 has a greater element than first element of LL2, then we swap the two elements involved. To keep LL2 sorted, we need to place first element of LL2 at its correct position. We can find mismatch by traversing LL2 once and correcting the pointers. ", "Below is C++ implementation of this idea.", "Output :\n", "Time Complexity : O(mn)", "This article is contributed by ", ". Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "In-place Merge two linked lists without changing links of first list"},
{"content": ["Given a ternary tree, create a doubly linked list out of it. A ternary tree is just like binary tree but instead of having two nodes, it has three nodes i.e. left, middle, right.", "The doubly linked list should holds following properties \u2013", "For the above example, the linked list formed for below tree should be NULL  5  1  4  8  11  6  7  15  63  31  55  65 -> NULL ", "The idea is to traverse the tree in preoder fashion similar to binary tree preorder traversal. Here, when we visit a node, we will insert it into doubly linked list in the end using a tail pointer. That we use to maintain the required insertion order. We then recursively call for left child, middle child and right child in that order.", "Below is C++ implementation of this idea.", "Output:\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "Create a Doubly Linked List from a Ternary Tree"},
{"content": ["Given K sorted linked lists of size N each, merge them and print the sorted output.", "Example:\n", "\u00a0", "\n", "\u00a0", "\n", "\u00a0", "\n", "We already know that ", " can be done in O(n) time and O(1) space (For arrays O(n) space is required). The idea is to pair up K lists and merge each pair in linear time using O(1) space. After first cycle, K/2 lists are left each of size 2*N. After second cycle, K/4 lists are left each of size 4*N and so on. We repeat the procedure until we have only one list left.  ", "Below is C++ implementation of the above idea.", "Output :\n", "Time Complexity of above algorithm is O(nk logk) as outer while loop in function mergeKLists() runs log k times and every time we are processing nk elements.  ", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "Merge K sorted linked lists"},
{"content": ["Given a singly linked list, delete middle  of the linked list. For example, if given linked list is 1->2->3->4->5 then linked list should be modified to 1->2->4->5", "If there are even nodes, then there would be two middle nodes, we need to delete the second middle element. For example, if given linked list is 1->2->3->4->5->6 then it should be modified to 1->2->3->5->6.", "If the input linked list is NULL, then it should remain NULL.", "If the input linked list has 1 node, then this node should be deleted and new head should be returned.", "A Simple Solution is to first count number of nodes in linked list, then delete n/2\u2019th node using the simple deletion process.  ", "The above solution requires two traversals of linked list.  We can delete middle node using one traversal.  The idea is to use two pointers, slow_ptr and fast_ptr.  Both pointers start from head of list.  When fast_ptr reaches end, slow_ptr reaches middle. This idea is same as the one used in method 2 of ", " post.  The additional thing in this post is to keep track of previous of middle so that we can delete middle.", "Below is C++ implementation.", "Output :\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "Delete middle of linked list"},
{"content": ["We have discussed ", " where nodes have two pointers down and next. In the previous post, we flattened the linked list level wise. How to flatten a linked list when we always need to process down pointer before next at every node.", "Source : Oracle Interview", "If we take a closer look, we can notice that this problem is similar to ", ". We recursively flatten a linked list with following steps.", " If node is NULL, return NULL.", "\n", " Store next node of current node (used in step 4).", "\n", " Recursively flatten down list.  While flattening, keep track of last visited node, so that the next list can be linked after it.", "\n", " Recursively flatten next list (we get the next list from pointer stored in step 2) and attach it after last visited node.", "Below is C++ implementation of above idea.", "Output:", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article using ", " or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."], "text": "Flatten a multi-level linked list | Set 2 (Depth wise)"},
{"content": ["Given a singly linked list of 0s and 1s find its decimal equivalent.\n", "Decimal Value of an empty linked list is considered as 0.", "Initialize result as 0.  Traverse the linked list and for each node, multiply the result by 2 and add node\u2019s data to it.", "Output :\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."], "text": "Decimal Equivalent of Binary Linked List"},
{"content": ["Given a list of integers, rearrange the list such that it consists of alternating minimum maximum elements ", ". The first element of the list should be minimum and second element should be maximum of all elements present in the list. Similarly, third element will be next minimum element and fourth element is next maximum element and so on. Use of extra space is not permitted.", "Examples:", "The idea is to sort the list in ascending order first. Then we start popping elements from the end of the list and insert them into their correct position in the list.", "Below is C++ implementation of above idea \u2013", "\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article using ", " or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."], "text": "Rearrange a given list such that it consists of alternating minimum maximum elements"},
{"content": ["Given a singly linked list, find if the linked list is ", " or not.  A linked list is called circular if it not NULL terminated and all nodes are connected in the form of a cycle.  Below is an example of circular linked list.", "An empty linked list is considered as circular.", "Note  that this problem is different from ", ", here all nodes have to be part of cycle.", "The idea is to store head of the linked list and traverse it.  If we reach NULL, linked list is not circular.  If reach head again, linked list is circular.", "Output :\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "Check if a linked list is Circular Linked List"},
{"content": ["Like array and linked list, unrolled Linked List is also a linear data structure and is a variant of linked list. Unlike simple linked list, it stores multiple elements at each node. That is, instead of storing single element at a node, unrolled linked lists store an array of elements at a node. Unrolled linked list covers advantages of both array and linked list as it reduces the memory overhead in comparison to simple linked lists by storing multiple elements at each node and it also has the advantage of fast insertion and deletion as that of a linked list.", "\nThe below program creates a simple unrolled linked list with 3 nodes containing variable number of elements in each.  It also traverses the created list.", "Output:", "In this article, we have introduced unrolled list and advantages of it.  We have also shown how to traverse the list.  In the next article, we will be discussing insertion, deletion and values of maxElements/numElements in detail.", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article using ", " or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."], "text": "Unrolled Linked List | Set 1 (Introduction)"},
{"content": ["Given a Binary Tree, convert it to a Circular Doubly Linked List (In-Place).", "\n", "The idea can be described using below steps.", "\n1) Write a general purpose function that concatenates two given circular doubly lists (This function is explained below).", "\n2) Now traverse the given tree", "\n\u2026.a) Recursively convert left subtree to a circular DLL.  Let the converted list be leftList.", "\n\u2026.a) Recursively convert right subtree to a circular DLL.   Let the converted list be rightList.", "\n\u2026.c) Make a circular linked list of root of the tree, make left and right of root to point to itself.", "\n\u2026.d) Concatenate leftList with list of single root node.", "\n\u2026.e) Concatenate the list produced in step above (d) with rightList.", "Note that the above code traverses tree in Postorder fashion.  We can traverse in inorder fashion also. We can first concatenate left subtree and root, then recur for right subtree and concatenate the result with left-root concatenation.", "Below are implementations of above idea.", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article using ", " or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."], "text": "Convert a Binary Tree to a Circular Doubly Link List"},
{"content": ["Given two linked lists that represent two large positive numbers. Subtract the smaller number from larger one and return the difference as a linked list.  Note that the input lists may be in any order, but we always need to subtract smaller from larger one.", "It may be assumed that there are no extra leading zeros in input lists.", "Examples", "Following are the steps.", "\n1) Calculate sizes of given two linked lists.", "\n2) If sizes not are same, then append zeros in smaller linked list.", "\n3) If size are same, then follow below steps:", "\n\u2026.a) Find the smaller valued linked list.", "\n\u2026.b) One by one subtract nodes of smaller sized linked list from larger size. Keep track of borrow while subtracting.", "Following is C implementation of the above approach.", "Output :\n", "This article is contributed by ", ". If you like GeeksforGeeks and would like to contribute, you can also write an article using ", " or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.", "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"], "text": "Subtract Two Numbers represented as Linked Lists"}
]